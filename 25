def run_pipeline(root_window):
    """
    Ejecuta todo el pipeline de generación de reportes.
    root_window: necesario para filedialog desde una app CTk.
    """
    conn = sqlite3.connect(DB_PATH)

    try:
        # 1. Cargar movimientos y unir con catálogo para obtener CLAVE_BANXICO
        df_mov = pd.read_sql("""
            SELECT 
                m.CONTRAPARTE,
                m.EMISION,
                m.TITULOS,
                m.ISIN,
                m.ENVIO_RECEPCION,
                c.CLAVE_BANXICO
            FROM MOVIMIENTOS m
            LEFT JOIN CAT_CONTRAPARTES c ON m.CONTRAPARTE = c.CONTRAPARTE
        """, conn)

        if df_mov.empty:
            messagebox.showwarning("Advertencia", "No hay movimientos cargados.")
            return

        # Asegurar que TITULOS sea numérico
        df_mov['TITULOS'] = pd.to_numeric(df_mov['TITULOS'], errors='coerce')

        # 2. Agrupar por CLAVE_BANXICO + EMISION (no por CONTRAPARTE)
        df_agrupado = df_mov.groupby(['CLAVE_BANXICO', 'EMISION'], as_index=False).agg({
            'TITULOS': 'sum',
            'ISIN': 'first',
            'ENVIO_RECEPCION': 'first'
        })

        # 3. Eliminar posiciones neteadas a cero
        df_agrupado = df_agrupado[df_agrupado['TITULOS'] != 0].copy()



        if df_agrupado.empty:
            messagebox.showinfo("Información", "No hay posiciones abiertas (todo neteado a cero).")
            return

        # 4. Volver a unir con CAT_CONTRAPARTES para recuperar CONTRAPARTE
        # (por si hay más de una contraparte por CLAVE_BANXICO, tomamos la primera)
        df_final = df_agrupado.merge(
            df_mov[['CLAVE_BANXICO', 'CONTRAPARTE']].drop_duplicates(),
            on='CLAVE_BANXICO',
            how='left'
        )

        # 5. Clasificar como nacional o extranjero
        df_final['TIPO'] = df_final['EMISION'].apply(classify_emision)
        total_titulos = df_final['TITULOS'].sum()
        messagebox.showinfo("Total", f"Suma total de títulos (neto): {total_titulos:,}")


--------------------------------------------->
        # Cargar Vector PIP
        pip_path = filedialog.askopenfilename(
            parent=root_window,
            title="Selecciona el archivo Vector PIP",
            filetypes=[("Archivos Excel", "*.xlsx *.xlsm *.xls")]
        )
        if not pip_path:
            raise Exception("Archivo Vector PIP no seleccionado.")

        pip_date = extract_date_from_pip_filename(os.path.basename(pip_path))
        if not pip_date:
            raise Exception("No se pudo extraer la fecha del archivo PIP. Asegúrate del formato: PIPYYYYMMDDM.xls")

        sheet_name = f"{pip_date}_MD"
        df_pip = pd.read_excel(pip_path, sheet_name=sheet_name)
        df_pip.rename(columns={'Emisora': 'EMISORA', 'Serie': 'SERIE', 'Tipo Valor': 'TIPO_VALOR', 'Precio Sucio': 'PRECIO_SUCIO'}, inplace=True)
        df_pip['EMISORA'] = df_pip['EMISORA'].apply(normalize_text)

        # Extraer solo las emisoras nacionales que necesitamos de df_final
        emisoras_nacionales = set(
            df_final[df_final['TIPO'] == 'NACIONAL']['EMISION']
            .str.split(' ', n=1, expand=True)[0]
            .apply(normalize_text)
            .unique()
        )

        # Filtrar df_pip a solo esas emisoras
        df_pip_filtrado = df_pip[df_pip['EMISORA'].apply(normalize_text).isin(emisoras_nacionales)].copy()

        # Cargar catálogo de TIPO_VALOR
        df_tipos = pd.read_sql("SELECT EMISORA, TIPO_VALOR FROM CAT_TIPO_VALOR", conn)
        df_tipos['EMISORA'] = df_tipos['EMISORA'].apply(normalize_text)

        # Detectar emisoras nuevas en df_pip_filtrado
        emisoras_pip = set(df_pip_filtrado['EMISORA'].apply(normalize_text).unique())
        emisoras_cat = set(df_tipos['EMISORA'].apply(normalize_text).unique())
        nuevas_emisoras = emisoras_pip - emisoras_cat

        for emisora in nuevas_emisoras:
            if messagebox.askyesno("Emisora no encontrada",
                                   f"No se encontró la emisora '{emisora}' en el catálogo de Tipo Valor.\n¿Desea darla de alta?"):
                tipo_valor = simpledialog.askstring("Tipo Valor", f"Ingrese TIPO_VALOR para '{emisora}':")
                if tipo_valor is None:
                    messagebox.showwarning("Cancelado", f"No se dio de alta el tipo de valor para '{emisora}'.")
                    continue

                cursor.execute("INSERT INTO CAT_TIPO_VALOR (EMISORA, TIPO_VALOR) VALUES (?, ?)",
                               (str(emisora), str(tipo_valor)))

        # Recargar catálogo actualizado
        df_tipos = pd.read_sql("SELECT EMISORA, TIPO_VALOR FROM CAT_TIPO_VALOR", conn)
        df_tipos['EMISORA'] = df_tipos['EMISORA'].apply(normalize_text)

        # Completar TIPO_VALOR en df_pip_filtrado
        df_pip_filtrado = df_pip_filtrado.merge(df_tipos[['EMISORA', 'TIPO_VALOR']], on='EMISORA', how='left')

        # Crear clave compuesta en df_pip_filtrado
        df_pip_filtrado['CLAVE_PIP'] = df_pip_filtrado['EMISORA'] + " " + df_pip_filtrado['SERIE'] + " " + df_pip_filtrado['TIPO_VALOR']

        # Extraer EMISORA y SERIE de df_final para nacionales
        emision_split = df_final['EMISION'].str.split(' ', n=1, expand=True)
        df_final['EMISORA_PARA_PIP'] = emision_split[0].apply(normalize_text)
        df_final['SERIE_PARA_PIP'] = emision_split[1]

        # Obtener TIPO_VALOR para df_final desde catálogo
        df_final = df_final.merge(
            df_tipos[['EMISORA', 'TIPO_VALOR']], 
            left_on='EMISORA_PARA_PIP', 
            right_on='EMISORA', 
            how='left', 
            suffixes=('', '_cat')
        )

        # Crear clave compuesta en df_final
        df_final['CLAVE_PARA_PIP'] = df_final['EMISORA_PARA_PIP'] + " " + df_final['SERIE_PARA_PIP'] + " " + df_final['TIPO_VALOR']

        # Cruzar con df_pip_filtrado (solo nacionales)
        df_final = df_final.merge(
            df_pip_filtrado[['CLAVE_PIP', 'PRECIO_SUCIO']],
            left_on='CLAVE_PARA_PIP',
            right_on='CLAVE_PIP',
            how='left',
            suffixes=('', '_pip')
        )

        # Cargar VMDS para precios faltantes (solo extranjeros)
        vmds_path = filedialog.askopenfilename(
            parent=root_window,
            title="Selecciona el archivo VMDS (CSV)",
            filetypes=[("CSV files", "*.csv")]
        )
        if not vmds_path:
            raise Exception("Archivo VMDS no seleccionado.")

        df_vmds = pd.read_csv(vmds_path, header=None, dtype=str)
        if df_vmds.shape[1] < 5:
            raise Exception("El archivo VMDS debe tener al menos 5 columnas.")

        df_vmds.rename(columns={0: 'EMISION_VMDS', 3: 'EMISORA_VMDS', 4: 'SERIE_VMDS'}, inplace=True)
        df_vmds['EMISORA_VMDS'] = df_vmds['EMISORA_VMDS'].apply(normalize_text)

        # Filtrar filas sin precio en df_final (solo extranjeros que aún no tienen precio)
        mask_sin_precio = df_final['PRECIO_SUCIO'].isna()
        df_sin_precio = df_final[mask_sin_precio].copy()

        df_extranjeros_sin_precio = df_sin_precio[df_sin_precio['TIPO'] == 'EXTRANJERO'].copy()

        if not df_extranjeros_sin_precio.empty:
            # Cruzar con VMDS para obtener EMISORA_VMDS y SERIE_VMDS
            df_extranjeros_sin_precio = df_extranjeros_sin_precio.merge(
                df_vmds[['EMISION_VMDS', 'EMISORA_VMDS', 'SERIE_VMDS']],
                left_on='EMISION',
                right_on='EMISION_VMDS',
                how='inner'
            )

            # Obtener TIPO_VALOR para EMISORA_VMDS desde catálogo
            df_extranjeros_sin_precio = df_extranjeros_sin_precio.merge(
                df_tipos[['EMISORA', 'TIPO_VALOR']],  # catálogo actualizado
                left_on='EMISORA_VMDS',
                right_on='EMISORA',
                how='left',
                suffixes=('', '_cat_vmds')
            )

            # Crear clave compuesta para cruce con Vector PIP
            df_extranjeros_sin_precio['CLAVE_VMDS_PIP'] = (
                df_extranjeros_sin_precio['EMISORA_VMDS'] + " " +
                df_extranjeros_sin_precio['SERIE_VMDS'] + " " +
                df_extranjeros_sin_precio['TIPO_VALOR']
            )

            # Cruzar con Vector PIP (ya filtrado y con clave compuesta)
            df_extranjeros_sin_precio = df_extranjeros_sin_precio.merge(
                df_pip_filtrado[['CLAVE_PIP', 'PRECIO_SUCIO']],
                left_on='CLAVE_VMDS_PIP',
                right_on='CLAVE_PIP',
                how='left',
                suffixes=('', '_pip_vmds')
            )

            # Actualizar precios en df_final
            for idx, row in df_extranjeros_sin_precio.iterrows():
                mask = (df_final['EMISION'] == row['EMISION']) & (df_final['TIPO'] == 'EXTRANJERO')
                df_final.loc[mask, 'PRECIO_SUCIO'] = row['PRECIO_SUCIO_pip_vmds']
