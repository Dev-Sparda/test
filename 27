import duckdb
import polars as pl
import json
from datetime import datetime
from pathlib import Path


# ==========================================================
# MOCK CONFIGURACIÃ“N HARDCODEADA
# ==========================================================

CONFIG_INSUMO = {
    "id_insumo": 1,
    "ruta_archivo": "insumo_mock.txt",  # <-- Hardcodeado
    "schema": {
        "LD_ID_GLOBAL": pl.Int64,
        "LD_IND01_ACT_EMP": pl.Utf8,
        "LD_TIPO_PERSONA": pl.Utf8,
        "LD_CON_PERSONA": pl.Utf8,
        "LD_FEC_REGISTRO": pl.Date
    },
    "cantidad_columnas": 5
}


# ==========================================================
# VALIDADOR MOCK
# ==========================================================

class ValidadorMock:

    def __init__(self, config):

        self.config = config
        self.conn = None
        self.df = None

        self.resultado = {
            "id_insumo": config["id_insumo"],
            "archivo": config["ruta_archivo"],
            "fecha_proceso": datetime.now(),
            "estructura_ok": False,
            "errores_estructura": [],
            "errores_negocio": []
        }

    def __enter__(self):
        self.conn = duckdb.connect(":memory:")
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        if self.conn:
            self.conn.close()

    # ======================================================
    # PROCESO COMPLETO
    # ======================================================

    def procesar(self):

        if not self._validar_estructura():
            return self.resultado

        self._validar_regla_mock()

        return self.resultado

    # ======================================================
    # VALIDACIÃ“N ESTRUCTURA
    # ======================================================

    def _validar_estructura(self):

        try:
            # ðŸ”¹ Lectura inicial para validar columnas
            df_temp = pl.read_csv(
                self.config["ruta_archivo"],
                separator="\t",
                infer_schema_length=10
            )

            if df_temp.width != self.config["cantidad_columnas"]:
                raise ValueError(
                    f"Columnas esperadas {self.config['cantidad_columnas']} "
                    f"- Recibidas {df_temp.width}"
                )

            # ðŸ”¹ Lectura con tipado fuerte
            self.df = pl.read_csv(
                self.config["ruta_archivo"],
                separator="\t",
                schema=self.config["schema"],
                try_parse_dates=True
            )

            # ðŸ”¹ Forzar formato de fecha especÃ­fico
            self.df = self.df.with_columns(
                pl.col("LD_FEC_REGISTRO")
                .str.strptime(pl.Date, "%Y-%m-%d", strict=True)
            )

            # ðŸ”¹ Registrar en DuckDB
            self.conn.register("datos", self.df.to_arrow())

            self.resultado["estructura_ok"] = True
            print("âœ“ Estructura vÃ¡lida")
            return True

        except Exception as e:
            self.resultado["errores_estructura"].append(str(e))
            print("âŒ Error estructural:", e)
            return False

    # ======================================================
    # VALIDACIÃ“N DE NEGOCIO MOCK
    # ======================================================

    def _validar_regla_mock(self):

        # Regla ejemplo:
        # Si LD_ID_GLOBAL es NULL o negativo â†’ error

        query = """
        SELECT 
            LD_ID_GLOBAL,
            'ID invÃ¡lido' AS error
        FROM datos
        WHERE LD_ID_GLOBAL IS NULL
           OR LD_ID_GLOBAL < 0
        """

        resultado = self.conn.execute(query).pl()

        # Contrato:
        # NULL -> OK
        # Filas -> Error

        if resultado.height > 0:
            self.resultado["errores_negocio"].append({
                "regla": "id_global_no_valido",
                "detalle": resultado.to_dicts()
            })
            print("âš  Errores de negocio detectados")
        else:
            print("âœ“ ValidaciÃ³n de negocio OK")


# ==========================================================
# EJECUCIÃ“N
# ==========================================================

if __name__ == "__main__":

    with ValidadorMock(CONFIG_INSUMO) as val:

        resultado = val.procesar()

        # ðŸ”¹ Generar log JSON
        with open("log_mock.json", "w", encoding="utf-8") as f:
            json.dump(resultado, f, indent=4, default=str)

        print("\nðŸ“ Log generado: log_mock.json")








def _validar_reglas_sql(self):

    carpeta = Path("Reglas") / str(self.config["id_insumo"])

    if not carpeta.exists():
        print("âš  No existen reglas para este insumo")
        return

    for archivo_sql in carpeta.glob("*.sql"):

        print(f"ðŸ”Ž Ejecutando regla: {archivo_sql.name}")

        with open(archivo_sql, "r", encoding="utf-8") as f:
            query = f.read()

        resultado = self.conn.execute(query).pl()

        # CONTRATO:
        # NULL -> OK
        # Filas -> Error

        if resultado.height == 1 and resultado.row(0)[0] is None:
            print("âœ“ Regla OK")
            continue

        if resultado.height > 0:
            print("âš  Errores detectados")
            self.resultado["errores_negocio"].append({
                "regla": archivo_sql.name,
                "detalle": resultado.to_dicts()
            })
