import polars as pl
import duckdb
import os
import subprocess
from datetime import datetime


class ValidadorSLA:

    def __init__(self, ruta_excel, config):
        self.ruta_excel = ruta_excel
        self.config = config
        self.conn = None
        self.df = None

    # üîπ Se ejecuta al entrar en el with
    def __enter__(self):
        self.conn = duckdb.connect(":memory:")
        self.conn.execute("""
            CREATE TABLE errores_estructura (
                archivo VARCHAR,
                error_mensaje VARCHAR,
                fecha TIMESTAMP
            )
        """)
        return self

    # üîπ Se ejecuta al salir del with (aunque haya error)
    def __exit__(self, exc_type, exc_value, traceback):
        self.liberar_archivo_onedrive()
        if self.conn:
            self.conn.close()
        print("üîí Recursos liberados correctamente")

    def cargar_y_validar(self):

        try:
            # Validaci√≥n cantidad columnas
            df_temp = pl.read_excel(self.ruta_excel, infer_schema_length=10)

            if df_temp.width != self.config["cantidad_columnas"]:
                raise ValueError(
                    f"Columnas esperadas: {self.config['cantidad_columnas']} - "
                    f"Recibidas: {df_temp.width}"
                )

            # Tipado fuerte
            self.df = pl.read_excel(
                self.ruta_excel,
                schema=self.config["schema"]
            )

            print("‚úì Archivo v√°lido estructuralmente")

        except Exception as e:
            print("‚ùå Error estructural")

            self.conn.execute(
                "INSERT INTO errores_estructura VALUES (?, ?, ?)",
                (self.ruta_excel, str(e), datetime.now())
            )

            return False

        # Registrar zero-copy
        self.conn.register("datos", self.df.to_arrow())
        print("‚úì Registrado en DuckDB (zero-copy)")

        return True

    def validar_negocio(self, query):
        return self.conn.execute(query).pl()

    def ver_errores(self):
        return self.conn.execute(
            "SELECT * FROM errores_estructura"
        ).fetchdf()

    def liberar_archivo_onedrive(self):

        if not os.path.exists(self.ruta_excel):
            print("‚ö†Ô∏è Archivo no existe f√≠sicamente")
            return

        try:
            result = subprocess.run(
                f'attrib +U -P "{self.ruta_excel}"',
                shell=True,
                capture_output=True,
                text=True
            )

            if result.returncode == 0:
                print("‚òÅÔ∏è Archivo liberado (modo nube)")
            else:
                print("‚ö†Ô∏è No se pudo liberar archivo:", result.stderr)

        except Exception as e:
            print("‚ö†Ô∏è Error liberando archivo:", e)



-------uso---
config_mock = {
    "cantidad_columnas": 3,
    "schema": {
        "id": pl.Int64,
        "nombre": pl.Utf8,
        "fecha": pl.Date
    }
}

ruta = "insumo_demo.xlsx"

with ValidadorSLA(ruta, config_mock) as validador:

    if validador.cargar_y_validar():

        resultado = validador.validar_negocio(
            "SELECT COUNT(*) as total FROM datos"
        )
        print(resultado)

    else:
        print("‚õî SLA incumplido")
