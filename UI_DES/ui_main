# ui_main.py
import customtkinter as ctk
from db_manager import get_all_desarrollos, get_fases_vencidas_sin_finalizar
from catalog_db import get_responsables_con_correo, get_usuarios_solicitantes

# Importar la funci√≥n para abrir el detalle
from ui_detalle import open_detalle_window

class MainView(ctk.CTkFrame):
    def __init__(self, parent, on_new_click):
        super().__init__(parent)
        self.on_new_click = on_new_click

        # Variables para los filtros
        self.filtro_responsable = ctk.StringVar(value="")
        self.filtro_estatus = ctk.StringVar(value="")

        self.create_widgets()
        self.load_filter_options()
        self.load_data()

    def create_widgets(self):
        # === Botones principales ===
        btn_frame = ctk.CTkFrame(self)
        btn_frame.pack(pady=10)

        self.btn_new = ctk.CTkButton(btn_frame, text="üÜï Nuevo Desarrollo", command=self.on_new_click)
        self.btn_new.pack(side="left", padx=5)

        self.btn_alert = ctk.CTkButton(btn_frame, text="üîç Verificar fases vencidas", command=self.verificar_y_notificar)
        self.btn_alert.pack(side="left", padx=5)

        # === Filtros ===
        filter_frame = ctk.CTkFrame(self)
        filter_frame.pack(pady=10, padx=20, fill="x")

        # Filtro por responsable
        ctk.CTkLabel(filter_frame, text="Responsable:").pack(side="left", padx=(10, 5))
        self.combo_responsable = ctk.CTkComboBox(
            filter_frame,
            variable=self.filtro_responsable,
            values=[""],  # Se llenar√° despu√©s
            width=180,
            command=self.on_filter_change
        )
        self.combo_responsable.pack(side="left", padx=5)

        # Filtro por estatus
        ctk.CTkLabel(filter_frame, text="Estatus:").pack(side="left", padx=(15, 5))
        self.combo_estatus = ctk.CTkComboBox(
            filter_frame,
            variable=self.filtro_estatus,
            values=["", "En an√°lisis", "En desarrollo", "Pausado", "Finalizado"],
            width=150,
            command=self.on_filter_change
        )
        self.combo_estatus.pack(side="left", padx=5)

        # Bot√≥n Limpiar
        self.btn_limpiar = ctk.CTkButton(filter_frame, text="üóëÔ∏è Limpiar", command=self.limpiar_filtros, width=80)
        self.btn_limpiar.pack(side="left", padx=15)

        # === Tabla de desarrollos ===
        self.table_frame = ctk.CTkScrollableFrame(self)
        self.table_frame.pack(fill="both", expand=True, padx=10, pady=5)

        headers = ["ID", "Reporte", "Responsable", "Estatus", "Inicio", "Tecnolog√≠a"]
        for i, h in enumerate(headers):
            lbl = ctk.CTkLabel(self.table_frame, text=h, font=("Arial", 12, "bold"))
            lbl.grid(row=0, column=i, padx=5, pady=5)

    def load_filter_options(self):
        """Carga los nombres de responsables para el filtro."""
        responsables_data = get_responsables_con_correo()
        nombres = [r[0] for r in responsables_data]
        self.combo_responsable.configure(values=[""] + sorted(set(nombres)))

    def on_filter_change(self, event=None):
        """Se ejecuta al cambiar cualquier filtro."""
        self.load_data()

    def limpiar_filtros(self):
        self.filtro_responsable.set("")
        self.filtro_estatus.set("")
        self.load_data()

    def load_data(self):
        # Limpiar tabla actual
        for widget in self.table_frame.winfo_children():
            if int(widget.grid_info()["row"]) > 0:
                widget.destroy()

        # Obtener todos los desarrollos
        desarrollos = get_all_desarrollos()

        # Aplicar filtros
        responsable_filtro = self.filtro_responsable.get()
        estatus_filtro = self.filtro_estatus.get()

        filtered = []
        for d in desarrollos:
            if responsable_filtro and d["RESPONSABLE_DESARROLLO"] != responsable_filtro:
                continue
            if estatus_filtro and d["ESTATUS"] != estatus_filtro:
                continue
            filtered.append(d)

        # Mostrar resultados
        for row_idx, d in enumerate(filtered, start=1):
            fields = [
                str(d["ID"]),
                d["REPORTE"] or "",
                d["RESPONSABLE_DESARROLLO"] or "",
                d["ESTATUS"] or "",
                d["FECHA_INICIO"] or "",
                d["TECNOLOGIA_USADA"] or ""
            ]
            for col_idx, val in enumerate(fields):
                label = ctk.CTkLabel(self.table_frame, text=val, cursor="hand2")
                label.grid(row=row_idx, column=col_idx, padx=5, pady=3)
                label.bind("<Button-1>", lambda e, dev_id=d["ID"]: open_detalle_window(self, dev_id))

    def verificar_y_notificar(self):
        from catalog_db import get_responsables_con_correo
        from email_notifier import enviar_alerta_correo
        from db_manager import get_fases_vencidas_sin_finalizar

        fases = get_fases_vencidas_sin_finalizar()
        if not fases:
            status = ctk.CTkLabel(self, text="‚úÖ No hay fases vencidas.", text_color="green")
            status.pack()
            self.after(3000, status.destroy)
            return

        responsables_correo = {r[0]: r[1] for r in get_responsables_con_correo()}

        for fase in fases:
            responsable = fase["RESPONSABLE_DESARROLLO"]
            correo = responsables_correo.get(responsable)
            if correo:
                enviar_alerta_correo(correo, responsable, fase)
            else:
                print(f"‚ö†Ô∏è Correo no encontrado para: {responsable}")

        status = ctk.CTkLabel(self, text=f"üìß Alertas enviadas para {len(fases)} fase(s) vencida(s).", text_color="orange")
        status.pack()
        self.after(4000, status.destroy)
